#pragma config(Sensor, dgtl1,  bumper,         sensorDigitalIn)
#pragma config(Motor,  port1,           LeftBackWheel, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           StarGrabber,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LiftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LiftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RightBackWheel, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


void move(char direction, float time)
{
	char dirKey[4] = {'F', 'B', 'R', 'L'};  // their indexes give their motor patterns in the 2D array

	typedef struct
	{
		int leftFront;
		int leftBack;
		int rightFront;
		int rightBack;
	} ELEMENT;

	ELEMENT dir[4] =
	{
		{127, -127, -127, 127}, // forward
		{-127, 127, 127, -127}, // back
		{127, -127, 127, -127}, // right
		{-127, 127, -127, 127} // left
	}
	
	// returns corresponding motor pattern to direction
	int motorPattern[4] = dir[dirKey.findfirst(direction)];
	
	motor[LeftFrontWheel] = motorPattern.leftFront;
	motor[LeftBackWheel] = motorPattern.leftBack;
	motor[RightFrontWheel] = motorPattern.rightFront;
	motor[RightBackWheel] = motorPattern.rightBack;
	if (time == 0) // use bumper if 0 is passed as the time parameter
	{
		waitUntil(SensorValue[bumper] == 1); // 1 = pressed
	}
	else
	{
		wait1Msec(time * 1000);
	}
	motor[LeftBackWheel] = 0;
	motor[LeftFrontWheel] = 0;
	motor[RightBackWheel] = 0;
	motor[RightFrontWheel] = 0;
}

void liftStar()
{
	motor[LiftLeft] = 127;
	motor[LiftRight] = -127;
	wait1Msec(1350);
	motor[LiftLeft] = 0;
	motor[LiftRight] = 0;
}

void putDownLift()
{
	motor[LiftLeft] = -127;
	motor[LiftRight] = 127;
	wait1Msec(740);
	motor[LiftLeft] = 0;
	motor[LiftRight] = 0;
}

task main()
{
	// autonomous
	float timeToMid = 2.8;
	motor[StarGrabber] = -50;
	move('B', timeToMid);
	liftStar();
	motor[StarGrabber] = 50;
	wait1Msec(800);
	motor[StarGrabber] = 0;
	wait1Msec(4000);
	move('F', 3);
	putDownLift();

	// driver control
	while (1 == 1)
	{
		if (vexRT[Ch3] != 1)
		{
			motor[LeftFrontWheel] = vexRT[Ch3];
			motor[LeftBackWheel] = -vexRT[Ch3];
		}
		else
		{
			motor[LeftFrontWheel] = 0;
			motor[LeftBackWheel] = 0;
		}

		if (vexRT[Ch2] != 1) {
			motor[RightBackWheel] = vexRT[Ch2];
			motor[RightFrontWheel] = -vexRT[Ch2];
		}
		else
		{
			motor[RightFrontWheel] = 0;
			motor[RightBackWheel] = 0;
		}

		if (vexRT[Btn5D] == 1)
		{
			motor[LiftLeft] = -127;
			motor[LiftRight] = 127;
		}
		else if (vexRT[Btn5U] == 1)
		{
			motor[LiftLeft] = 127;
			motor[LiftRight] = -127;
		}
		else
		{
			motor[LiftLeft] = 0;
			motor[LiftRight] = 0;
		}

		if (vexRT[Btn6D] == 1)
		{
			motor[StarGrabber] = -70;
		}
		else if (vexRT[Btn6U] == 1)
		{
			motor[StarGrabber] = 70;
		}
		else
		{
			motor[StarGrabber] = 0;
		}
	}

}
