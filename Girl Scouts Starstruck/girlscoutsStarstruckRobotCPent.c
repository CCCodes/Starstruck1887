#pragma config(Sensor, in1,    shoulder,       sensorPotentiometer)
#pragma config(Sensor, in2,    elbow,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  bumper,         sensorDigitalIn)
#pragma config(Sensor, dgtl2,  jump,           sensorDigitalIn)
#pragma config(Motor,  port1,           RightBackWheel, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           StarGrabberRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LiftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LiftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           HangLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           StarGrabberLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           HangRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LeftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LeftBackWheel, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define HANG_RIGHT_UP -127
#define HANG_RIGHT_DOWN 127
#define HANG_LEFT_UP 127
#define HANG_LEFT_DOWN -127
#define STAR_GRABBER_CLOSE -60
#define STAR_GRABBER_OPEN 60

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(9999999)


//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void move(char direction, float time, bool useBumper)
{
	switch (direction)
	{
	case 'F':
		motor[LeftFrontWheel] = 127;
		motor[LeftBackWheel] = -127;
		motor[RightFrontWheel] = -127;
		motor[RightBackWheel] = 127;
		break;
	case 'B':
		motor[LeftFrontWheel] = -127;
		motor[LeftBackWheel] = 127;
		motor[RightFrontWheel] = 127;
		motor[RightBackWheel] = -127;
		break;
	case 'R':
		motor[LeftFrontWheel] = 127;
		motor[LeftBackWheel] = -127;
		motor[RightFrontWheel] = 127;
		motor[RightBackWheel] = -127;
		break;
	case 'L':
		motor[LeftFrontWheel] = -127;
		motor[LeftBackWheel] = 127;
		motor[RightFrontWheel] = -127;
		motor[RightBackWheel] = 127;
		break;
	default:
		return;
	}

	int countRunTimeMsec = 0;
	if (useBumper) // use bumper if 0 is passed as the time parameter
	{
		// just in case the sensor is never pushed
		// 1 means not pushed
		while (SensorValue[bumper] == 1 && countRunTimeMsec < time * 1000.0)
		{
			wait1Msec(10);
			countRunTimeMsec += 10;
		} // stopped because max time exceeded or bumper value is 1
		// could have used untilTouch http://cdn.robotc.net/pdfs/natural-language/NL_Cortex_Quick.pdf

	} // not bumper
	else
	{
		wait1Msec(time * 1000);
	}

	// time parameter finished so stop
	motor[LeftBackWheel] = 0;
	motor[LeftFrontWheel] = 0;
	motor[RightBackWheel] = 0;
	motor[RightFrontWheel] = 0;

	// and now wait a second before next function
	wait1Msec(1000);
}

void stopStarGrabber()
{
	motor[StarGrabberLeft] = 0;
	motor[StarGrabberRight] = 0;
}
void liftBar() {
	//	untilPotentiometerGreaterThan(2500, in1);

}
// currently called  with (2530, 850);
void liftStarPont(int shoulderValue, int elbowValue)
{
	motor[LiftLeft] = 127;
	motor[LiftRight] = -127;
	wait1Msec(1400); // time between lift starting and grabber angle changing (change angle time)
	motor[StarGrabberRight] = 40;
	motor[StarGrabberLeft] = -40;
	bool shoulderStop = false;
	bool elbowStop = false;
	// first round to get to parallel to ground
	clearTimer(T1);
	while(true   &&  time1[T1] < 3000)// and timer value less than max
	{
		if (SensorValue(shoulder) > 2557) // currently called with 2530--was 2707
		{
			motor[LiftLeft] = 0;
			motor[LiftRight] = 0;
			shoulderStop = true;
		}
		if (SensorValue(elbow) < 123)  // currently 850
		{
			stopStarGrabber();
			elbowStop = true;
		}
		if (shoulderStop && elbowStop)
		{
			break;
		}
	}

// last elbow throw

	motor[StarGrabberLeft] = 100;
	motor[StarGrabberRight] = -100;
	clearTimer(T2);
	while(true  &&  time1[T2] < 800)
	{
		if (SensorValue(elbow) > 2130 ) // was 1800
		{
			stopStarGrabber();
			break;
		}
	}
}

void liftStar()
{
	motor[StarGrabberRight] = 40;
	motor[StarGrabberLeft] = -40;
	wait1Msec(800);
	stopStarGrabber();
	motor[LiftLeft] = 127;
	motor[LiftRight] = -127;
	wait1Msec(400);  // was 500
	motor[StarGrabberRight] = 40;
	motor[StarGrabberLeft] = -40;
	wait1Msec(250); // was 300
	stopStarGrabber();
	//lifted part of the way
	wait1Msec(400); //was 500
	motor[StarGrabberRight] = -40;
	motor[StarGrabberLeft] = 40;
	wait1Msec(150); // was 200
	stopStarGrabber();
	/**	motor[StarGrabberLeft] = -30;
	motor[StarGrabberRight] = 30;
	wait1Msec(1500); **/
	//stopStarGrabber();
	//flatten star grabber
	wait1Msec(200);
	motor[StarGrabberRight] = -40;
	motor[StarGrabberLeft] = 40;
	wait1Msec(200);
	stopStarGrabber();
	wait1Msec(300);
	motor[StarGrabberLeft] = 127;
	motor[StarGrabberRight] = -127;
	wait1Msec(200);
	stopStarGrabber();
	motor[LiftLeft] = 0;
	motor[LiftRight] = 0;
	//end of toss

	wait1Msec(1000);
	move('F', .5, false);
	//motor[StarGrabberLeft] = -40;
	//motor[StarGrabberRight] = 40;
	//wait1Msec(600);
	//stopStarGrabber();

	//motor[LiftLeft] = -100;
	//motor[LiftRight] = 100;
	//wait1Msec(1000);
	//motor[LiftLeft] = 0;
	//motor[LiftRight] = 0;

}

void putDownLift()
{
	motor[LiftLeft] = -127;
	motor[LiftRight] = 127;
	wait1Msec(1000);
	motor[LiftLeft] = 0;
	motor[LiftRight] = 0;
}

void liftHang()
{
	motor[HangLeft] = HANG_LEFT_UP;
	motor[HangRight] = HANG_RIGHT_UP;
	wait1Msec(4500);
	motor[HangLeft] = 0;
	motor[HangRight] = 0;
}

void dropHang()
{
	motor[HangLeft] = HANG_LEFT_DOWN;
	motor[HangRight] = HANG_RIGHT_DOWN;
	wait1Msec(4000);
	motor[HangLeft] = 0;
	motor[HangRight] = 0;
}


void smack()
{
	/** comment out because stargrabber changed configuration
	motor[StarGrabber] = 70;
	wait1Msec(600);
	motor[StarGrabber] = -70;
	wait1Msec(600);
	motor[StarGrabber] = 0;
	**/
}
void GSxutonomousOldOne()
{
	float timeToMid = 3.5;
	//	motor[StarGrabber] = -70;
	move('B', 4, true);
	//	motor[StarGrabber] = 0;
	putDownLift();
	move('F', .2, false);
	liftHang();
	dropHang();
	//	move('F', 2.7, false);
	/**
	float turnToStraighten = .4;
	if (SensorValue[jump] == 0) // jump is in
	{
	move('L', turnToStraighten, false); // for left side
	}
	else
	{
	move('R', turnToStraighten, false); // for r ight side
	}
	move('B', timeToMid, true);
	liftHang();
	dropHang();
	liftStar();
	motor[StarGrabber] = 40;
	move('B', 1, true);
	wait1Msec(500);
	motor[StarGrabber] = 0;
	smack();
	move('F', 2, false);
	// has pushed star over
	// turn right and smack stars on fence
	if (SensorValue[jump] == 0) // jump is in
	{
	move('R', .7, false); // for left side
	}
	else
	{
	move('L', .7, false); // for right side
	}
	move('B', .5, false);
	smack();
	move('B', .5, false);
	smack();
	move('B', .5, false);
	smack();
	//putDownLift();
	**/
}
void GSautonomousJustPush()
{

	//	motor[StarGrabberRight] = -40;
	//	motor[StarGrabberLeft] = 40;
	//	wait1Msec(1000);
	//	stopStarGrabber();
	move('B', 4, true);
	move('L', .01, true);
	int count;
	for(count= 1;count <= 4; count = count+1){
	   move('F', .3, false);
	   move('B', .3, false);

//  GSautonomousPart2();
   }

}

void GSautonomous()
{

	//	motor[StarGrabberRight] = -40;
	//	motor[StarGrabberLeft] = 40;
	//	wait1Msec(1000);
	//	stopStarGrabber();
	move('B', 4, true);
	move('F', .3, false);
	liftHang();
	dropHang();
	move('B', .1, false);
//  GSautonomousPart2();
}
	void GSautonomousPart2(){
	//liftStarPont(2530, 850);
	liftStar();
	putDownLift();
	move('F', 3, false);

	wait1Msec(1000);
	motor[StarGrabberRight] = -40;
	motor[StarGrabberLeft] = 40;
	wait1Msec(500);
	stopStarGrabber();
	move('B', 4, true);
	move('F', .3, false);
	liftStar();
	move('B', .1, false);
}
void setToScoop(){
	// only works correctly if elbow and shoulder start bent in
 // should be fixed
	//send down until 288 or less
clearTimer(T1);
	while (SensorValue(shoulder) > 248 &&  time1[T1] < 3000){
		motor[LiftLeft] = -127;
		motor[LiftRight] = 127;
	}
	motor[LiftLeft] = 0;
	motor[LiftRight] = 0;
	// send elbow down until 2350 or less
	clearTimer(T1);
	while (SensorValue(elbow) > 2538    &&  time1[T1] < 3000){
		motor[StarGrabberRight] = 40;
		motor[StarGrabberLeft] = -40;
	}
	//  untilPotentiometerLessThan(3060, in2);

	motor[StarGrabberRight] = 0;
	motor[StarGrabberLeft] = 0;
}

void pre_auton()
{
// Set bStopTasksBetweenModes to false if you want to keep user created tasks
// running between Autonomous and Driver controlled modes. You will need to
// manage all user created tasks if set to false.
bStopTasksBetweenModes = true;

}

task autonomous()
{

	if (SensorValue[jump] == 0) // jump is in
	{
	//	wait1Msec(5000);
	//	move('F', 4, true);
	}
	GSautonomous();

}

task usercontrol()
{
// User control code here, inside the loop
int pottest = 1;

while (true)
{
	if (vexRT[Ch3] != 1) // Right jostick circle control moves forward and back
	{
		motor[LeftFrontWheel] = vexRT[Ch3];
		motor[LeftBackWheel] = -vexRT[Ch3];
	}
	else
	{
		motor[LeftFrontWheel] = 0;
		motor[LeftBackWheel] = 0;
	}

	if (vexRT[Ch2] != 1) {
		motor[RightBackWheel] = vexRT[Ch2];
		motor[RightFrontWheel] = -vexRT[Ch2];
	}
	else
	{
		motor[RightFrontWheel] = 0;
		motor[RightBackWheel] = 0;
	}

	if (vexRT[Btn5D] == 1) // 5 Lift 2 arms up and down
	{
		motor[LiftLeft] = -127;
		motor[LiftRight] = 127;
	}
	else if (vexRT[Btn5U] == 1)
	{
		motor[LiftLeft] = 127;
		motor[LiftRight] = -127;
	}
	else
	{
		motor[LiftLeft] = 0;
		motor[LiftRight] = 0;
	}

	if (vexRT[Btn6D] == 1) // 6 is up and down of elbow
	{
		motor[StarGrabberRight] = 40;
		motor[StarGrabberLeft] = -40;
		continue;
	}
	else if (vexRT[Btn6U] == 1)
	{
		motor[StarGrabberRight] = -40;
		motor[StarGrabberLeft] = 40;
		continue;
	}
	else
	{
		motor[StarGrabberRight] = 0;
		motor[StarGrabberLeft] = 0;
	}

	// control both hanging motors with button 7 U and D;
	if (vexRT[Btn7U] == 1)
	{
		motor[HangLeft] = HANG_LEFT_UP;
		motor[HangRight] = HANG_RIGHT_UP;
		continue; // so it doesn't hit the else statements that set the motors to 0
	}
	else if (vexRT[Btn7D] == 1)
	{
		motor[HangLeft] = HANG_LEFT_DOWN;
		motor[HangRight] = HANG_RIGHT_DOWN;
		continue; // so it doesn't hit the else statements that set the motors to 0
	}
	else
	{
		motor[HangLeft] = 0;
		motor[HangRight] = 0;
	}

	if (vexRT[Btn7L] == 1) // handles left arm alone using left and right 7
	{
		motor[HangLeft] = HANG_LEFT_UP;
	}
	else if (vexRT[Btn7R] == 1)
	{
		motor[HangLeft] = HANG_LEFT_DOWN;
	}
	else
	{
		motor[HangLeft] = 0;
	}

	if (vexRT[Btn8L] == 1) // handles right arm alone using lefgt and right 8
	{
		motor[HangRight] = HANG_RIGHT_UP;
	}
	else if (vexRT[Btn8R] == 1)
	{
		motor[HangRight] = HANG_RIGHT_DOWN;
	}
	else
	{
		motor[HangRight] = 0;
	}
	// run autonomous when 8Up is pushed

	if (vexRT[Btn8U] == 1)
	{
		//GSautonomous();
		//liftStarPont(2530, 850);
		liftStar();
	}
  if (vexRT[Btn8D] == 1) // 6 down will put the scoop arm on the floor using potentiometer
	{
		 setToScoop() ;
		// only works correctly if elbow and shoulder start bent in
	 // should be fixed
	}

	/** coding partner button 6
	    just add Xmtr2 to the button name **/
	if (vexRT[Btn6DXmtr2] == 1) // 6 down will run autonomous
  {
         	GSautonomous() ;
         	continue;
        // only works correctly if elbow and shoulder start bent in
     // should be fixed
  }
   /**
  if (vexRT[Btn6UXmtr2] == 1) // 6 up will run lift star and then end of autonomous
  {
  	  GSautonomousPart2()
        // only works correctly if elbow and shoulder start bent in
     // should be fixed
  }
**/
if (vexRT[Btn7DXmtr2] == 1) // 7 down will run lift star pont
  {
         liftStarPont(2530, 850);
        // only works correctly if elbow and shoulder start bent in
     // should be fixed
         continue;
  }

  if (vexRT[Btn7UXmtr2] == 1) // 7 up will run lift star
  {
         liftStar();
        // only works correctly if elbow and shoulder start bent in
     // should be fixed
         continue;
  }
 if (vexRT[Btn5UXmtr2] == 1) // 5 up will run autonomous push
  {
         GSautonomousJustPush();
        // only works correctly if elbow and shoulder start bent in
     // should be fixed
         continue;
  }




}
}
