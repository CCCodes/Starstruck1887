#pragma config(Sensor, in1,    shoulder,       sensorPotentiometer)
#pragma config(Sensor, in2,    elbow,          sensorPotentiometer)
#pragma config(Sensor, dgtl1,  jump,           sensorDigitalIn)
#pragma config(Sensor, dgtl2,  bumper,         sensorTouch)
#pragma config(Motor,  port1,           RightBackWheel, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           RightFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           TinyWheel,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LiftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LiftRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           HangLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           ConeGrabberMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           HangRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LeftFrontWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LeftBackWheel, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Opens Debug Stream Window automatically
#pragma DebuggerWindows("DebugStream")

#define HANG_RIGHT_SPEED 127 // this is the up speed direction
#define HANG_LEFT_SPEED -127 // this is the up speed direction

#define GRABBER_CLOSE -60
#define GRABBER_OPEN 60

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(9999999)


//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
// values for controlling autonomous
   //
   // remember to consider .4 sec added every time the wheels move because
   //     move adds a little stop.
   int grabberSlowSpeed = 30;
   int grabberFastSpeed = 100  ;

   float grabberCloseTime = .25;
   float hangArmUpTime = 4;
   int hangArmUpSpeed = 127;
   char turnPoleDirection = 'R' ;

   float turnPoleTime = .3;

   float travelPoleTime = 3;
   bool stopAtButtonIndicator = true;
   float backAfterPoleTime = .5;

   float hangArmDownTime = 1.5;
   int hangArmDownSpeed = 60;
   float grabberOpenTime = .25;
   float finalBackTime = .25;

void move(char direction, float time, bool useBumper)// time in seconds
{
	switch (direction)
	{
	case 'F':
		motor[LeftFrontWheel] = 127;
		motor[LeftBackWheel] = -127;
		motor[RightFrontWheel] = -127;
		motor[RightBackWheel] = 127;
		break;
	case 'B':
		motor[LeftFrontWheel] = -127;
		motor[LeftBackWheel] = 127;
		motor[RightFrontWheel] = 127;
		motor[RightBackWheel] = -127;
		break;
	case 'R':
		motor[LeftFrontWheel] = 127;
		motor[LeftBackWheel] = -127;
		motor[RightFrontWheel] = 127;
		motor[RightBackWheel] = -127;
		break;
	case 'L':
		motor[LeftFrontWheel] = -127;
		motor[LeftBackWheel] = 127;
		motor[RightFrontWheel] = -127;
		motor[RightBackWheel] = 127;
		break;
	default:
		return;
	}

	int countRunTimeMsec = 0;
	if (useBumper) //
	{
		// just in case the sensor is never pushed
		// 1 means not pushed

		while (SensorValue[bumper] == 0 && countRunTimeMsec < time * 1000.0)
		{
			wait1Msec(10);
			countRunTimeMsec += 10;
		} // stopped because max time exceeded or bumper value is 1
		// could have used untilTouch http://cdn.robotc.net/pdfs/natural-language/NL_Cortex_Quick.pdf

	} // not bumper
	else
	{
		wait1Msec(time * 1000);
	}

	// time parameter finished so stop
	motor[LeftBackWheel] = 0;
	motor[LeftFrontWheel] = 0;
	motor[RightBackWheel] = 0;
	motor[RightFrontWheel] = 0;

	// and now wait a short time before next function
	wait1Msec(400);
}


void stopHangArm()
{
	motor[HangLeft] = 0;
	motor[HangRight] = 0;
}
void stopLiftBox()
{
		motor[LiftLeft] = 0;
   	motor[LiftRight] = 0;
}


void moveHangArm(char dir, int speed ){
	if (dir == 'D'){
		motor[HangLeft] = speed;
   	motor[HangRight] = (speed * -1);
  }
  else
  {
    motor[HangLeft] = (speed * -1);
   	motor[HangRight] = speed;
  }

}

void moveLiftBox(char dir, int speed){
	if (dir == 'U'){
		motor[LiftLeft] = speed;
   	motor[LiftRight] = (speed * -1);
  }
  else
  {
    motor[LiftLeft] = (speed * -1);
   	motor[LiftRight] = speed;
  }
}
void openConeGrabber (int speed){
	  motor[ConeGrabberMotor] = (speed * -1);
}
void closeConeGrabber (int speed){

		motor[ConeGrabberMotor] = (speed );
 }
void stopConeGrabber()
{
	motor[ConeGrabberMotor] = 0;
}

void GSautonomous()
{
   // the grabber will snap shut for a time and then apply low pressure until it opens
   closeConeGrabber ( grabberFastSpeed);
   wait1Msec (grabberCloseTime * 1000);
   closeConeGrabber ( grabberSlowSpeed); // after closing, this applies constant pressure
   //
   // move the arm up and then stop - eventually make this a potentiometer
   moveHangArm('U', hangArmUpSpeed); // move up now that you grabbed the cone
   wait1Msec (hangArmUpTime * 1000);
   stopHangArm();
   // set left/right
      if (SensorValue[jump] == 0) // jump is in
		{
			turnPoleDirection = 'L'; // turn left when jump 12 is in
		}
		else
		{
			turnPoleDirection = 'R'; // turn right when jump 12 is out
		}
   // go to the pole, hit it and back up a bit
   move(turnPoleDirection, turnPoleTime, false);  // turn to pole
   move('F', travelPoleTime, stopAtButtonIndicator);  // get to pole
   move('B', backAfterPoleTime, false);  // back up after hitting pole
   //
   // put the arm down slowly
   moveHangArm('D', hangArmDownSpeed); // move up now that you grabbed the cone
   wait1Msec (hangArmDownTime * 1000);
   stopHangArm();
   // open the grabber quickly and then stop
   openConeGrabber ( grabberFastSpeed);
   wait1Msec (grabberOpenTime * 1000);
   stopConeGrabber();
   // Back up when the cone is released
   move('B', finalBackTime, false);
}


void pre_auton()
{
// Set bStopTasksBetweenModes to false if you want to keep user created tasks
// running between Autonomous and Driver controlled modes. You will need to
// manage all user created tasks if set to false.
bStopTasksBetweenModes = true;

}

task autonomous()
{

	if (SensorValue[jump] == 0) // jump is in
	{
	//	wait1Msec(5000);
	//	move('F', 4, true);
	// do GSautonomousJustPushHere
	}
	GSautonomous();
}

task usercontrol()
{
// User control code here, inside the loop, jasmine here is where the joystick code is

while (true)
{
	if (vexRT[Ch3] != 1) // Right jostick circle control moves forward and back
	{
		motor[LeftFrontWheel] = vexRT[Ch3];
		motor[LeftBackWheel] = -vexRT[Ch3];
	}
	else
	{
		motor[LeftFrontWheel] = 0;
		motor[LeftBackWheel] = 0;
	}

	if (vexRT[Ch2] != 1) {
		motor[RightBackWheel] = vexRT[Ch2];
		motor[RightFrontWheel] = -vexRT[Ch2];
	}
	else
	{
		motor[RightFrontWheel] = 0;
		motor[RightBackWheel] = 0;
	}

	if (vexRT[Btn5D] == 1) // 5 Lift  box up and down
	{
		motor[LiftLeft] = -127;
		motor[LiftRight] = 127;
	}
	else if (vexRT[Btn5U] == 1)
	{
		motor[LiftLeft] = 127;
		motor[LiftRight] = -127;
	}
	else
	{
		motor[LiftLeft] = 0;
		motor[LiftRight] = 0;
	}

	if (vexRT[Btn8R] == 1) // 8R opens the conegrabber and 8L closes it and 8U applies small pressure
	{
 		motor[ConeGrabberMotor] = -100; // fast open 8R
	}
	else if (vexRT[Btn8L] == 1)
	{
 		motor[ConeGrabberMotor] = 100; // fast close 8L
	}
	else if (vexRT[Btn8U] == 1)
	{
		motor[ConeGrabberMotor] = 30; // very slow close 8U
	}
	else if (vexRT[Btn8D] == 1)
	{
		motor[ConeGrabberMotor] = -40; // very slow open 8D
	}
	else
	{
		motor[ConeGrabberMotor] = 0;
	}

  // control the lift box with the # 6 buttons
	if (vexRT[Btn6U] == 1)
	{
		motor[HangLeft] = HANG_LEFT_SPEED ;
		motor[HangRight] = HANG_RIGHT_SPEED;

	}
	else if (vexRT[Btn6D] == 1)
	{
		motor[HangLeft] = HANG_LEFT_SPEED * -1;
		motor[HangRight] = HANG_RIGHT_SPEED * -1;

	}
	else
	{
		motor[HangLeft] = 0;
		motor[HangRight] = 0;
	}

	  // control the tiny wheel with the 7 up and down button
	if (vexRT[Btn7U] == 1)
	{
		motor[TinyWheel] = 127;
	}
	else if (vexRT[Btn7D] == 1)
	{
 		motor[TinyWheel] = -127;
	}
	else
	{
		motor[TinyWheel] = 0;

	}

	// run autonomous when 7R is pushed


	if (vexRT[Btn7R] == 1)
	{
	  	GSautonomous();
    // continue;


       motor[TinyWheel] = 0;

	}
	if (vexRT[Btn7L] == 1){
		 if( SensorValue[bumper]  == 1 )
     {  motor[TinyWheel] = -127; }

  }
	/** coding partner button 6
	    just add Xmtr2 to the button name
	if (vexRT[Btn6DXmtr2] == 1) // 6 down will run autonomous
  {
         	GSautonomous() ;
  }
  **/


}
}
